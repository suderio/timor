/*
 * generated by Xtext 2.10.0
 */
package net.technearts.jvmmodel

import com.google.inject.Inject
import java.util.HashMap
import net.technearts.timor.ClassDeclaration
import net.technearts.timor.File
import net.technearts.timor.MethodDeclaration
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class TimorJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider

	def dispatch void infer(File file, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val ops = new HashMap<JvmOperation, JvmGenericType>();
		for (declaration : file.declarations) {
			switch declaration {
				MethodDeclaration: {
					ops.put( declaration.toMethod(declaration.method.methodName, declaration.method.type) [
						documentation = declaration.documentation
						static = declaration.method.scope == 'type'
						for (p : declaration.method.params) {
							parameters += p.toParameter(p.name, p.parameterType)
						}
						body = declaration.method.body
					], declaration.method.toClass(declaration.method.fullyQualifiedName))
				}
			}
		}
		for (declaration : file.declarations) {
			switch declaration {
				ClassDeclaration: {
					acceptor.accept(declaration.klazz.toClass(declaration.klazz.fullyQualifiedName)) [
						documentation = declaration.documentation
						if (declaration.klazz.extend != null && declaration.klazz.extend.size > 0) {
							// TODO est√° pegando o primeiro elemento como classe
							superTypes += declaration.klazz.extend.get(0).cloneWithProxies
						}
						for (p : declaration.klazz.properties) {
							members += p.property.toField(p.property.name, p.property.type)
							members += p.property.toSetter(p.property.name, p.property.type)
							members += p.property.toGetter(p.property.name, p.property.type)
						}
						for (entry : ops.entrySet) {
							if (entry.value.fullyQualifiedName.equals(declaration.klazz.fullyQualifiedName)){
								members += entry.key
							}
						}
					]
				}
			}
		}
	}
}
