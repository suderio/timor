/*
 * generated by Xtext 2.10.0
 */
package net.technearts.jvmmodel

import com.google.inject.Inject
import java.util.HashMap
import net.technearts.timor.File
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class TimorJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider

	def dispatch void infer(File file, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val ops = new HashMap<JvmOperation, JvmGenericType>();
		for (method : file.methods) {
			ops.put( method.toMethod(method.methodName, method.type) [
				documentation = method.documentation
				static = method.scope == 'type'
				for (p : method.params) {
					parameters += p.toParameter(p.name, p.parameterType)
				}
				body = method.body
			], method.toClass(method.fullyQualifiedName))
		}
		for (klazz : file.classes) {
			acceptor.accept(klazz.toClass(klazz.fullyQualifiedName)) [
				documentation = klazz.documentation
				if (klazz.extend != null && klazz.extend.size > 0) {
					// TODO est√° pegando o primeiro elemento como classe
					superTypes += klazz.extend.get(0).cloneWithProxies
				}
				for (p : klazz.properties) {
					members += p.toField(p.name, p.type)
					members += p.toSetter(p.name, p.type)
					members += p.toGetter(p.name, p.type)
				}
				for (entry : ops.entrySet) {
					if (entry.value.fullyQualifiedName.equals(klazz.fullyQualifiedName)){
						members += entry.key
					}
				}
			]
		}
	}
}
